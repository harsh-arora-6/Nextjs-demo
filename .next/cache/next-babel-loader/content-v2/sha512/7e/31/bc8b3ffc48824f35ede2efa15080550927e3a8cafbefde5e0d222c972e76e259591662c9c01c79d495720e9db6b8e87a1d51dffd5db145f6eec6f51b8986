{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { MongoClient, ObjectId } from \"mongodb\";\nimport MeetupDetail from \"../../components/meetups/MeetupDetail\";\nimport { Fragment } from \"react\";\nimport Head from \"next/head\";\n\nfunction MeetupDetails(props) {\n  return /*#__PURE__*/_jsxs(Fragment, {\n    children: [/*#__PURE__*/_jsxs(Head, {\n      children: [/*#__PURE__*/_jsx(\"title\", {\n        children: props.title\n      }), /*#__PURE__*/_jsx(\"meta\", {\n        name: \"description\",\n        content: props.description\n      })]\n    }), /*#__PURE__*/_jsx(MeetupDetail, {\n      image: props.meetupData.image,\n      title: props.meetupData.title,\n      address: props.meetupData.address,\n      description: props.meetupData.description\n    })]\n  });\n} // this function is required in dynamic pages when using getStaticProps\n\n\nexport async function getStaticPaths() {\n  // we can dynamically generate paths by fetching the array of ids from database,\n  // fallback = false means that only the paths defined should exist\n  // fallback = true means for the defined paths pages should be pre generated while the other pages will be dynamically pre generated on the server for the incoming request\n  //   with the help of fallback we can pre generate some popular pages\n  const client = await MongoClient.connect(\"mongodb+srv://harsh_arora:iBk8oP6RjVv1O34V@cluster0.jfh4zpi.mongodb.net/?retryWrites=true&w=majority\");\n  const db = client.db(\"meetups\");\n  const meetupsCollection = db.collection(\"meetups\");\n  const meetups = await meetupsCollection.find({}, {\n    _id: 1\n  }).toArray();\n  client.close(); // with true it would immediately return an empty page and then pull down the dynamically generated content once thats done so we need to handle the case when page doesn't have data yet\n  // with blocking user won't see anything until the page is pre generated (new page)\n\n  return {\n    fallback: \"blocking\",\n    paths: meetups.map(meetup => ({\n      params: {\n        meetupId: meetup._id.toString()\n      }\n    }))\n  };\n}\nexport async function getStaticProps(context) {\n  // fetch data from API or take to some database\n  //   here context won't have request,response\n  const meetupId = context.params.meetupId;\n  const client = await MongoClient.connect(\"mongodb+srv://harsh_arora:iBk8oP6RjVv1O34V@cluster0.jfh4zpi.mongodb.net/?retryWrites=true&w=majority\");\n  const db = client.db(\"meetups\");\n  const meetupsCollection = db.collection(\"meetups\");\n  const selectedMeetup = await meetupsCollection.findOne({\n    _id: ObjectId(meetupId)\n  });\n  client.close();\n  return {\n    // here props is the props which we receive in above component.\n    // this is how we can move data fetching away from client side to the build process side\n    props: {\n      meetupData: {\n        id: meetupId,\n        image: selectedMeetup.image,\n        title: selectedMeetup.title,\n        address: selectedMeetup.address,\n        description: selectedMeetup.description\n      }\n    },\n    // time in seconds after which the page should be re pre-rendered with the new data.\n    // page is updated regularly after deployment(not only at build time)\n    revalidate: 1\n  };\n}\nexport default MeetupDetails;","map":null,"metadata":{},"sourceType":"module"}